import datetime
import decimal
import math
import os

import psycopg2
from dbutils.pooled_db import PooledDB

from src.model import DatabaseConfig
from src.strategy.database_strategy import DatabaseStrategy
from src.tools.postgresql_tools import PostgreSQLTools


class PostgreSQLStrategy(DatabaseStrategy):

    def __init__(self, config: DatabaseConfig):
        super().__init__(config)
        self.pool = None

    def create_pool(self) -> PooledDB:
        if not self.pool:
            # Connect to postgres database by default, then use schema
            self.pool = PooledDB(
                creator=psycopg2,
                host=self.config.host,
                port=self.config.port,
                user=self.config.user,
                password=self.config.password,
                database='postgres',  # Connect to default postgres database
                mincached=self.config.minCached or 5,
                maxcached=self.config.maxCached or 10,
                maxconnections=self.config.maxConnections or 20,
                dsn=f"host={self.config.host} port={self.config.port} user={self.config.user} password={self.config.password} dbname=postgres options='-c search_path={self.config.database}'"
            )
        return self.pool

    def get_connection(self):
        if not self.pool:
            self.create_pool()
        return self.pool.connection()

    def close_connection(self, connection: object) -> None:
        if connection:
            connection.close()

    def list_tables(self) -> str:
        connection = self.get_connection()
        try:
            with connection.cursor() as cursor:
                cursor.execute(
                    """
                    SELECT t.tablename                        AS table_name,
                           obj_description(c.oid, 'pg_class') AS table_comment
                    FROM pg_tables t
                             JOIN pg_class c ON c.relname = t.tablename
                             JOIN pg_namespace n ON n.oid = c.relnamespace AND n.nspname = t.schemaname
                    WHERE t.schemaname = %s
                    ORDER BY t.tablename
                    """,
                    (self.config.database,)
                )
                tables = cursor.fetchall()

                headers = ["TABLE_NAME", "TABLE_COMMENT"]
                return self.format_table(headers, list(tables))
        finally:
            self.close_connection(connection)

    def describe_Table(self, table_name: str) -> str:
        connection = self.get_connection()
        try:
            with connection.cursor() as cursor:
                cursor.execute(
                    """
                    SELECT a.attname                            AS column_name,
                           col_description(c.oid, a.attnum)     AS column_comment,
                           format_type(a.atttypid, a.atttypmod) AS data_type,
                           format_type(a.atttypid, a.atttypmod) AS column_type,
                           pg_get_expr(d.adbin, d.adrelid)      AS column_default,
                           CASE
                               WHEN pk.conname IS NOT NULL THEN 'PRI'
                               WHEN uk.conname IS NOT NULL THEN 'UNI'
                               ELSE ''
                               END                              AS column_key,
                           CASE
                               WHEN a.attnotnull THEN 'NO'
                               ELSE 'YES'
                               END                              AS is_nullable,
                           CASE
                               WHEN a.attidentity = 'd' THEN 'GENERATED BY DEFAULT AS IDENTITY'
                               WHEN a.attidentity = 'a' THEN 'GENERATED ALWAYS AS IDENTITY'
                               ELSE ''
                               END                              AS extra
                    FROM pg_attribute a
                             JOIN pg_class c ON c.oid = a.attrelid
                             JOIN pg_namespace n ON n.oid = c.relnamespace
                             LEFT JOIN pg_attrdef d ON d.adrelid = a.attrelid AND d.adnum = a.attnum
                             LEFT JOIN pg_constraint pk ON pk.conrelid = c.oid
                        AND pk.contype = 'p'
                        AND a.attnum = ANY (pk.conkey)
                             LEFT JOIN pg_constraint uk ON uk.conrelid = c.oid
                        AND uk.contype = 'u'
                        AND a.attnum = ANY (uk.conkey)
                    WHERE c.relname = %s
                      AND n.nspname = %s
                      AND a.attnum > 0
                      AND NOT a.attisdropped
                    ORDER BY a.attnum
                    """,
                    (table_name, self.config.database)
                )
                table_infos = cursor.fetchall()

                result_infos = []
                for table_info in table_infos:
                    index_names = PostgreSQLTools.get_column_index_names(cursor, table_name, table_info[0])

                    info_list = list(table_info)
                    if index_names and info_list[5]:
                        info_list[5] = f"{info_list[5]} ({', '.join(index_names)})"
                    result_infos.append(tuple(info_list))

                headers = [
                    "COLUMN_NAME",
                    "COLUMN_COMMENT",
                    "DATA_TYPE",
                    "COLUMN_TYPE",
                    "COLUMN_DEFAULT",
                    "COLUMN_KEY",
                    "IS_NULLABLE",
                    "EXTRA",
                ]
                return self.format_table(headers, result_infos)
        finally:
            self.close_connection(connection)

    def execute_sql(self, sql: str, params: tuple = None) -> str:
        connection = self.get_connection()
        try:
            with connection.cursor() as cursor:
                sql_stripped = sql.strip()

                if sql_stripped.upper().startswith("SELECT"):
                    cursor.execute(sql_stripped, params)
                    column_names = [desc[0] for desc in cursor.description]
                    result = cursor.fetchall()
                    return self.format_table(column_names, list(result))
                else:
                    cursor.execute(sql_stripped, params)
                    connection.commit()
                    affected_rows = cursor.rowcount
                    return self.format_update(affected_rows)
        except Exception as e:
            connection.rollback()
            raise e
        finally:
            self.close_connection(connection)

    def export_data(self, table_name: str, file_path: str = None) -> str:
        connection = self.get_connection()
        try:
            with connection.cursor() as cursor:
                if not table_name.replace('_', '').replace('-', '').isalnum():
                    raise ValueError(f"Invalid table name: {table_name}")

                cursor.execute(
                    f"""
                    SELECT COUNT(*)
                    FROM "{table_name}"
                    """
                )
                count = cursor.fetchone()[0]
                if count <= 0:
                    return f"Table '{table_name}' has no data."

                if not file_path:
                    script_dir = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
                    file_path = os.path.join(script_dir, "export_data")

                os.makedirs(file_path, exist_ok=True)

                batch_size = 1000
                file_count = math.ceil(count / batch_size)

                for i in range(file_count):
                    offset = i * batch_size
                    cursor.execute(
                        f"""
                        SELECT *
                        FROM "{table_name}"
                        LIMIT {batch_size} OFFSET {offset}
                        """
                    )
                    rows = cursor.fetchall()

                    if not rows:
                        continue

                    headers = [desc[0] for desc in cursor.description]

                    insert_values = []
                    for row in rows:
                        values = []
                        for val in row:
                            if val is None:
                                values.append("NULL")
                            elif isinstance(val, str):
                                escaped_val = val.replace("'", "''")
                                values.append(f"'{escaped_val}'")
                            elif isinstance(val, (datetime.datetime, datetime.date, datetime.time)):
                                values.append(f"'{val}'")
                            elif isinstance(val, bytes):
                                hex_val = val.hex()
                                values.append(f"E'\\\\x{hex_val}'")
                            elif isinstance(val, bool):
                                values.append("TRUE" if val else "FALSE")
                            elif isinstance(val, (int, float, decimal.Decimal)):
                                values.append(str(val))
                            else:
                                escaped_val = str(val).replace("'", "''")
                                values.append(f"'{escaped_val}'")
                        insert_values.append(f"({', '.join(values)})")

                    quoted_headers = '", "'.join(headers)
                    insert_sql = f'INSERT INTO "{table_name}" ("{quoted_headers}") VALUES '
                    insert_sql += ", ".join(insert_values) + ";"

                    file_name = os.path.join(file_path, f"{table_name}_{i}.sql")
                    with open(file_name, "w", encoding='utf-8') as f:
                        f.write(insert_sql)

                return f"Exported {count} rows to {file_path}."
        finally:
            self.close_connection(connection)

    def execute_sql_file(self, file_path: str) -> str:
        connection = self.get_connection()
        affected_rows = 0
        try:
            with connection.cursor() as cursor:
                if not file_path or not os.path.exists(file_path):
                    raise FileNotFoundError(f"File not found: {file_path}")

                if os.path.isdir(file_path):
                    sql_content = self.read_all_files(file_path)
                    for sql in sql_content:
                        cursor.execute(sql)
                        if sql.strip().upper().startswith('ALTER TABLE'):
                            affected_rows += 1
                        elif cursor.rowcount > 0:
                            affected_rows += cursor.rowcount
                else:
                    if not file_path.endswith('.sql'):
                        raise ValueError(f"Invalid file type: {file_path}")
                    with open(file_path, 'r', encoding='utf-8') as f:
                        content = f.read()
                        statements = content.split(';')
                        for statement in statements:
                            sql_stripped = statement.strip()
                            if sql_stripped:
                                cursor.execute(sql_stripped)
                                if sql_stripped.upper().startswith('ALTER TABLE'):
                                    affected_rows += 1
                                elif cursor.rowcount > 0:
                                    affected_rows += cursor.rowcount
                connection.commit()
                return self.format_update(affected_rows)
        except Exception as e:
            connection.rollback()
            raise e
        finally:
            self.close_connection(connection)

    def compare_table_with(self, table_name: str, other_strategy: 'DatabaseStrategy',
                           generate_sql: bool = False) -> str:
        try:
            my_structure = self.get_table_structure(table_name)
            other_structure = other_strategy.get_table_structure(table_name)

            sql_file_path = None
            if generate_sql:
                # Use base class method to generate ALTER statements with PostgreSQL-specific comparison
                alter_statements = self.generate_alter_statements(
                    table_name, my_structure, other_structure, PostgreSQLTools,
                    compare_method_name='compare_columns_with_type_normalization'
                )

                if alter_statements:
                    sql_file_path = PostgreSQLTools.save_alter_sql(
                        table_name, alter_statements, other_strategy.config.database
                    )

            return self.format_comparison_result(table_name, my_structure, other_structure,
                                                 other_strategy, sql_file_path)

        except Exception as e:
            return f"Table structure comparison failed: {str(e)}"

    def get_table_structure(self, table_name: str) -> dict:
        connection = self.get_connection()
        try:
            with connection.cursor() as cursor:
                cursor.execute(
                    """
                    SELECT a.attname                            AS column_name,
                           format_type(a.atttypid, a.atttypmod) AS column_type,
                           CASE
                               WHEN a.attnotnull THEN 'NO'
                               ELSE 'YES'
                               END                              AS is_nullable,
                           CASE
                               WHEN pk.conname IS NOT NULL THEN 'PRI'
                               WHEN uk.conname IS NOT NULL THEN 'UNI'
                               ELSE ''
                               END                              AS column_key,
                           pg_get_expr(d.adbin, d.adrelid)      AS column_default,
                           CASE
                               WHEN a.attidentity = 'd' THEN 'GENERATED BY DEFAULT AS IDENTITY'
                               WHEN a.attidentity = 'a' THEN 'GENERATED ALWAYS AS IDENTITY'
                               ELSE ''
                               END                              AS extra,
                           col_description(c.oid, a.attnum)     AS column_comment
                    FROM pg_attribute a
                             JOIN pg_class c ON c.oid = a.attrelid
                             JOIN pg_namespace n ON n.oid = c.relnamespace
                             LEFT JOIN pg_attrdef d ON d.adrelid = a.attrelid AND d.adnum = a.attnum
                             LEFT JOIN pg_constraint pk ON pk.conrelid = c.oid
                        AND pk.contype = 'p'
                        AND a.attnum = ANY (pk.conkey)
                             LEFT JOIN pg_constraint uk ON uk.conrelid = c.oid
                        AND uk.contype = 'u'
                        AND a.attnum = ANY (uk.conkey)
                    WHERE c.relname = %s
                      AND n.nspname = %s
                      AND a.attnum > 0
                      AND NOT a.attisdropped
                    ORDER BY a.attnum
                    """,
                    (table_name, self.config.database)
                )

                columns = cursor.fetchall()

                if not columns:
                    raise ValueError(f"Table '{table_name}' does not exist in database '{self.config.database}'")

                return PostgreSQLTools.parse_table_structure(columns)

        finally:
            self.close_connection(connection)
